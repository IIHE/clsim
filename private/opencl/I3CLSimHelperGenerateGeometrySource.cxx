#include "opencl/I3CLSimHelperGenerateGeometrySource.h"

#include <string>
#include <sstream>
#include <stdexcept>

#include <vector>
#include <set>

#include "dataclasses/I3Constants.h"

#include <boost/lexical_cast.hpp>
#include <boost/foreach.hpp>

#include "clsim/cl.hpp"

#include "clsim/to_float_string.h"


namespace I3CLSimHelper
{
    
    // forward
    bool write_geometry_code_and_fill_buffer(std::string &code, 
                                             const std::vector<int> &stringIDs,
                                             const std::vector<unsigned int> &domIDs,
                                             const std::vector<double> &posX,
                                             const std::vector<double> &posY,
                                             const std::vector<double> &posZ,
                                             const double omRadius,
                                             std::vector<cl_uchar> &geoLayerToOMNumIndexPerStringSetBuffer,
                                             std::vector<int> &stringIndexToStringIDBuffer
                                             );
    
    // the main converter
    std::string GenerateGeometrySource(const I3CLSimSimpleGeometry &geometry,
                                       std::vector<unsigned char> &geoLayerToOMNumIndexPerStringSetBuffer,
                                       std::vector<int> &stringIndexToStringIDBuffer)
    {
        geoLayerToOMNumIndexPerStringSetBuffer.clear();
        stringIndexToStringIDBuffer.clear();
        
        std::ostringstream code;
        
        code << "\n";
        code << "///////////////// BEGIN ice/water properties ////////////\n";
        code << "\n";

        code << "// ice/water properties, auto-generated by\n";
        code << "// I3CLSimHelper::GenerateGeometrySource()\n";
        code << "\n";

        {
            std::string geo_code;
            bool ret = 
            write_geometry_code_and_fill_buffer(geo_code, 
                                                geometry.GetStringIDVector(),
                                                geometry.GetDomIDVector(),
                                                geometry.GetPosXVector(),
                                                geometry.GetPosYVector(),
                                                geometry.GetPosZVector(),
                                                geometry.GetOMRadius(),
                                                geoLayerToOMNumIndexPerStringSetBuffer,
                                                stringIndexToStringIDBuffer
                                                );
            
            if (!ret)
                throw std::runtime_error("Could not use this geometry for OpenCL.");
            
            code << geo_code;
        }        
        
        code << "\n";
        code << "///////////////// END ice/water properties ////////////\n";
        code << "\n";

        
        return code.str();
    }
    

    
    /////////// HELPERS
    
    struct domStruct {
        unsigned int domID;
        double posX, posY, posZ;
    };
    
    struct stringStruct {
        int stringID;
        double meanX;
        double meanY;
        double maxZ, minZ;
        double maxR;
        std::vector<domStruct> doms;
    };
    
    bool divideIntoCells(const std::vector<stringStruct> &strings,
                         double &cellStartX,
                         double &cellStartY,
                         double &cellWidthX,
                         double &cellWidthY,
                         unsigned int cellNumX,
                         unsigned int cellNumY,
                         std::vector<unsigned short> &cellToStringIndex)
    {
        if ((cellNumX==0) || (cellNumY==0)) {log_fatal("cell count is zero");}
        if (strings.size()<=0) {log_fatal("no strings found");}
        
        log_trace("New division try: cellNumX=%u cellNumY=%u", cellNumX, cellNumY);
        
        cellToStringIndex.resize(cellNumX*cellNumY);
        
        // find minimum x and y detector coordinates
        double minX=NAN, minY=NAN, maxX=NAN, maxY=NAN;
        BOOST_FOREACH(const stringStruct &currentString, strings)
        {
            if ((currentString.meanX-currentString.maxR < minX) || isnan(minX)) {
                minX = currentString.meanX-currentString.maxR;
            }
            if ((currentString.meanY-currentString.maxR < minY) || isnan(minY)) {
                minY = currentString.meanY-currentString.maxR;
            }
            if ((currentString.meanX+currentString.maxR > maxX) || isnan(maxX)) {
                maxX = currentString.meanX+currentString.maxR;
            }
            if ((currentString.meanY+currentString.maxR > maxY) || isnan(maxY)) {
                maxY = currentString.meanY+currentString.maxR;
            }
        }
        
        // calculte cell widths
        cellStartX=minX;
        cellStartY=minY;
        cellWidthX=(maxX-minX)/static_cast<double>(cellNumX);
        cellWidthY=(maxY-minY)/static_cast<double>(cellNumY);
        
        std::set<unsigned short> assignedStringNums;
        
        //unsigned int numAssignedStrings=0;
        
        for (unsigned int i=0;i<cellNumX;++i)
        {
            for (unsigned int j=0;j<cellNumY;++j)
            {
                const double cellXMin = cellStartX+static_cast<double>(i)*cellWidthX;
                const double cellXMax = cellStartX+static_cast<double>(i+1)*cellWidthX;
                const double cellYMin = cellStartY+static_cast<double>(j)*cellWidthY;
                const double cellYMax = cellStartY+static_cast<double>(j+1)*cellWidthY;
                
                bool stringFound=false;
                unsigned long stringFoundNum=0xFFFF;
                // we got a cell, now loop over all strings to find if any one is in here
                
                for (unsigned long thisString=0;thisString<strings.size();++thisString)
                {
                    const stringStruct &currentString = strings[thisString];
                    
                    bool cellContainsStringX=false;
                    bool cellContainsStringY=false;
                    
                    if ((currentString.meanX-currentString.maxR <= cellXMin) &&
                        (currentString.meanX+currentString.maxR >= cellXMin))
                        cellContainsStringX=true;
                    if ((currentString.meanX-currentString.maxR <= cellXMax) &&
                        (currentString.meanX+currentString.maxR >= cellXMax))
                        cellContainsStringX=true;
                    if ((currentString.meanX-currentString.maxR >= cellXMin) &&
                        (currentString.meanX+currentString.maxR <= cellXMax))
                        cellContainsStringX=true;
                    if ((currentString.meanY-currentString.maxR <= cellYMin) &&
                        (currentString.meanY+currentString.maxR >= cellYMin))
                        cellContainsStringY=true;
                    if ((currentString.meanY-currentString.maxR <= cellYMax) &&
                        (currentString.meanY+currentString.maxR >= cellYMax))
                        cellContainsStringY=true;
                    if ((currentString.meanY-currentString.maxR >= cellYMin) &&
                        (currentString.meanY+currentString.maxR <= cellYMax))
                        cellContainsStringY=true;
                    
                    if ((cellContainsStringX) && (cellContainsStringY))
                    {
                        if (stringFound) 
                        {
                            log_trace("Segmentation is not valid, string %lu and %lu are in the same cell.",
                                      thisString, stringFoundNum);
                            log_trace("  -> string %lu reaches from x=[%f,%f], y=[%f,%f]",
                                      thisString,
                                      currentString.meanX-currentString.maxR, currentString.meanX+currentString.maxR,
                                      currentString.meanY-currentString.maxR, currentString.meanY+currentString.maxR);
                            log_trace("  -> string %lu reaches from x=[%f,%f], y=[%f,%f]",
                                      stringFoundNum,
                                      strings[stringFoundNum].meanX-strings[stringFoundNum].maxR, strings[stringFoundNum].meanX+strings[stringFoundNum].maxR,
                                      strings[stringFoundNum].meanY-strings[stringFoundNum].maxR, strings[stringFoundNum].meanY+strings[stringFoundNum].maxR);
                            return false; // two strings per cell -> fail!
                        }
                        stringFound=true;
                        stringFoundNum=thisString;
                        assignedStringNums.insert(thisString);
                        //++numAssignedStrings;
                    }
                } //for(string)
                
                if (stringFound) {
                    cellToStringIndex[j*cellNumX+i] = stringFoundNum;
                } else {
                    cellToStringIndex[j*cellNumX+i] = 0xFFFF;
                }
                
                
            } // for(j)
        } // for(i)
        
        
        if (assignedStringNums.size()!=strings.size()) {
            std::cerr << "Internal error in cell division algorithm." << std::endl;
        }
        
        return true;
        
    }
    
    bool doesMatchLayering(const stringStruct &currentString,
                           double layerStartZ,
                           double layerHeight,
                           unsigned int layerNum,
                           const double domRadius,
                           const std::vector<unsigned char> &layerToOMNumIndex)
    {
        if (layerNum==0) return false;
        if (domRadius < 0.) return false;
        if (currentString.doms.size() >= 0xFF) {
            std::cerr << "Dom numbers >= 255 are not supported!" << std::endl;
            exit(-4);
        }
        if (layerToOMNumIndex.size() != layerNum)
        {
            std::cerr << "Internal error: layerToOMNumIndex.size() != layerNum" << std::endl;
            exit(-4);
        }
        
        for (unsigned int i=0;i<layerNum;++i)
        {
            const double layerZMin = layerStartZ+static_cast<double>(i)*layerHeight;
            const double layerZMax = layerStartZ+static_cast<double>(i+1)*layerHeight;
            
            unsigned char layerShouldContainDom=0xFF;
            
            for (unsigned long thisDom=0;thisDom<currentString.doms.size();++thisDom)
            {
                const domStruct &currentDom = currentString.doms[thisDom];
                double domZ = currentDom.posZ;
                
                bool layerContainsDom=false;
                
                if ((domZ-domRadius <= layerZMin) &&
                    (domZ+domRadius >= layerZMin))
                    layerContainsDom=true;
                if ((domZ-domRadius <= layerZMax) &&
                    (domZ+domRadius >= layerZMax))
                    layerContainsDom=true;
                if ((domZ-domRadius >= layerZMin) &&
                    (domZ+domRadius <= layerZMax))
                    layerContainsDom=true;
                
                
                if (layerContainsDom)
                {
                    if (layerShouldContainDom!=0xFF) {
                        return false; // two different doms from the same string per layer -> fail!
                    } else {
                        layerShouldContainDom = thisDom;
                    }
                }
                
            } // for(dom)
            
            if (layerToOMNumIndex[i] != layerShouldContainDom) {
                //std::cout << "Layer " << i << " should contain OM " << (int)layerToOMNumIndex[i] << " but contains " << (int)layerShouldContainDom << std::endl;
                return false; // incompatible
            }
            
        } // for (i)
        
        return true; // everything is compatible
    }
    
    void findOverallStringMinMaxZ(const std::vector<stringStruct> &strings,
                                  const double domRadius,
                                  double &minZ,
                                  double &maxZ)
    {
        minZ=maxZ=NAN;
        
        BOOST_FOREACH(const stringStruct& currentString, strings)
        {
            if ((currentString.minZ-domRadius < minZ) || isnan(minZ)) {
                minZ = currentString.minZ-domRadius;
            }
            if ((currentString.maxZ+domRadius > maxZ) || isnan(maxZ)) {
                maxZ = currentString.maxZ+domRadius;
            }
        }	
    }
    
    bool divideIntoLayers(const stringStruct &currentString,
                          double &layerStartZ,
                          double &layerHeight,
                          unsigned int layerNum,
                          const double domRadius,
                          double minZHint, double maxZHint,
                          std::vector<unsigned char> &layerToOMNumIndex)
    {
        if (layerNum==0) return false;
        if (domRadius < 0.) return false;
        if (currentString.doms.size() >= 0xFF) {
            std::cerr << "Dom numbers >= 255 are not supported!" << std::endl;
            exit(-4);
        }
        
        // set all layers on each string to "no doms inside"
        layerToOMNumIndex.assign(layerNum, 0xFF);
        
        // find minimum and maximum z detector coordinates
        double minZ=minZHint, maxZ=maxZHint;
        if ((currentString.minZ-domRadius < minZ) || isnan(minZ)) {
            minZ = currentString.minZ-domRadius;
        }
        if ((currentString.maxZ+domRadius > maxZ) || isnan(maxZ)) {
            maxZ = currentString.maxZ+domRadius;
        }
        
        // calculate layer heights
        layerStartZ=minZ;
        layerHeight=(maxZ-minZ)/static_cast<double>(layerNum);
        
        for (unsigned int i=0;i<layerNum;++i)
        {
            const double layerZMin = layerStartZ+static_cast<double>(i)*layerHeight;
            const double layerZMax = layerStartZ+static_cast<double>(i+1)*layerHeight;
            
            // we got a layer, now loop over all strings to find if any one is in here
            
            for (unsigned long thisDom=0;thisDom<currentString.doms.size();++thisDom)
            {
                const domStruct &currentDom = currentString.doms[thisDom];
                double domZ = currentDom.posZ;
                
                bool layerContainsDom=false;
                
                if ((domZ-domRadius <= layerZMin) &&
                    (domZ+domRadius >= layerZMin))
                    layerContainsDom=true;
                if ((domZ-domRadius <= layerZMax) &&
                    (domZ+domRadius >= layerZMax))
                    layerContainsDom=true;
                if ((domZ-domRadius >= layerZMin) &&
                    (domZ+domRadius <= layerZMax))
                    layerContainsDom=true;
                
                
                if (layerContainsDom)
                {
                    if (layerToOMNumIndex[i]!=0xFF) {
                        return false; // two different doms from the same string per layer -> fail!
                    } else {
                        layerToOMNumIndex[i] = thisDom;
                    }
                }
                
            } // for(dom)
            
        } // for(i)
        
        return true;	
    }
    
    namespace {
        bool isStringInTemplate(const stringStruct &string,
                                const std::vector<std::vector<double> > &allTemplatePositionsX,
                                const std::vector<std::vector<double> > &allTemplatePositionsY,
                                const std::vector<std::vector<double> > &allTemplatePositionsZ,
                                double offsetX, double offsetY,
                                std::size_t &templateNumber
                                )
        {
            if (allTemplatePositionsX.size() != allTemplatePositionsY.size()) log_fatal("Internal error. template sizes differ x!=y (1)");
            if (allTemplatePositionsX.size() != allTemplatePositionsZ.size()) log_fatal("Internal error. template sizes differ x!=z (1)");
            
            const double epsilon=1e-4*I3Units::m;
            
            for (std::size_t i=0;i<allTemplatePositionsX.size();++i)
            {
                const std::vector<double> &templateXPositions = allTemplatePositionsX[i];
                const std::vector<double> &templateYPositions = allTemplatePositionsY[i];
                const std::vector<double> &templateZPositions = allTemplatePositionsZ[i];
                if (templateXPositions.size() != templateYPositions.size()) log_fatal("Internal error. template sizes differ x!=y (2)");
                if (templateXPositions.size() != templateZPositions.size()) log_fatal("Internal error. template sizes differ x!=z (2)");

                if (string.doms.size() != templateXPositions.size()) continue; // cannot match
                
                for (std::size_t j=0;j<string.doms.size();++j)
                {
                    const domStruct &currentDomStruct = string.doms[j];
                    
                    const double diffX = std::abs(templateXPositions[j]-(currentDomStruct.posX-offsetX));
                    const double diffY = std::abs(templateYPositions[j]-(currentDomStruct.posY-offsetY));
                    const double diffZ = std::abs(templateZPositions[j]-(currentDomStruct.posZ));
                    
                    if (diffX>epsilon) break; // does not match
                    if (diffY>epsilon) break; // does not match
                    if (diffZ>epsilon) break; // does not match
                    
                    // match!
                    templateNumber=i;
                    return true;
                }
            }

            return false; // no match found
        }
        
    }
    
    std::string generate_get_dom_position_code(const std::vector<stringStruct> &strings)
    {
        std::vector<double> stringMeanPosX(strings.size(), 0.);
        std::vector<double> stringMeanPosY(strings.size(), 0.);
        std::vector<std::size_t> stringMeanPosXYEntries(strings.size(), 0);

        std::size_t maxNumDoms=0;
        double geoDomPosMaxAbsX=NAN;
        double geoDomPosMaxAbsY=NAN;
        double geoDomPosMaxAbsZ=NAN;
        for (std::size_t i=0;i<strings.size();++i)
        {
            if (strings[i].doms.size() > maxNumDoms) maxNumDoms=strings[i].doms.size();
            
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                const domStruct &currentDomStruct = strings[i].doms[j];
                
                double absX = fabs(currentDomStruct.posX);
                double absY = fabs(currentDomStruct.posY);
                double absZ = fabs(currentDomStruct.posZ);
                
                if ((absX > geoDomPosMaxAbsX) || isnan(geoDomPosMaxAbsX)) geoDomPosMaxAbsX=absX;
                if ((absY > geoDomPosMaxAbsY) || isnan(geoDomPosMaxAbsY)) geoDomPosMaxAbsY=absY;
                if ((absZ > geoDomPosMaxAbsZ) || isnan(geoDomPosMaxAbsZ)) geoDomPosMaxAbsZ=absZ;
                
                stringMeanPosXYEntries[i]++;
                stringMeanPosX[i]+=currentDomStruct.posX;
                stringMeanPosY[i]+=currentDomStruct.posY;
            }
        }

        for (std::size_t i=0;i<strings.size();++i)
        {
            stringMeanPosX[i] /= static_cast<double>(stringMeanPosXYEntries[i]);
            stringMeanPosY[i] /= static_cast<double>(stringMeanPosXYEntries[i]);
        }
        
        std::vector<std::size_t> stringInTemplate(strings.size());
        std::vector<std::vector<double> > templatePositionsX;
        std::vector<std::vector<double> > templatePositionsY;
        std::vector<std::vector<double> > templatePositionsZ;
        
        for (std::size_t i=0;i<strings.size();++i)
        {
            const bool stringIsInTemplate = 
            isStringInTemplate(strings[i],
                               templatePositionsX,
                               templatePositionsY,
                               templatePositionsZ,
                               stringMeanPosX[i], stringMeanPosY[i],
                               stringInTemplate[i]);
            
            if (stringIsInTemplate) continue; // nothing else to do, string is now registered in stringInTemplate[i]
            
            // make a new template
            templatePositionsX.push_back(std::vector<double>(strings[i].doms.size(), NAN));
            templatePositionsY.push_back(std::vector<double>(strings[i].doms.size(), NAN));
            templatePositionsZ.push_back(std::vector<double>(strings[i].doms.size(), NAN));
            
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                const domStruct &currentDomStruct = strings[i].doms[j];

                templatePositionsX.back()[j] = currentDomStruct.posX-stringMeanPosX[i];
                templatePositionsY.back()[j] = currentDomStruct.posY-stringMeanPosY[i];
                templatePositionsZ.back()[j] = currentDomStruct.posZ;
                
                stringInTemplate[i] = templatePositionsX.size()-1;
            }
        }
        
        std::vector<double> templatePositionsX_flat;
        std::vector<double> templatePositionsY_flat;
        std::vector<double> templatePositionsZ_flat;
        std::vector<std::size_t> templateIndexIntoFlatList(templatePositionsZ.size());

        for (std::size_t i=0;i<templatePositionsX.size();++i)
        {
            templateIndexIntoFlatList[i] = templatePositionsX_flat.size();
            for (std::size_t j=0;j<templatePositionsX[i].size();++j)
            {
                templatePositionsX_flat.push_back(templatePositionsX[i][j]);
                templatePositionsY_flat.push_back(templatePositionsY[i][j]);
                templatePositionsZ_flat.push_back(templatePositionsZ[i][j]);
            }
        }
        
        
        
        log_debug("There are %zu string templates for %zu strings", templatePositionsX.size(), strings.size());
        
        std::vector<cl_float> domPosBuffer;
        
        domPosBuffer.assign(strings.size()*maxNumDoms*4, NAN);
        
        for (std::size_t i=0;i<strings.size();++i)
        {
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                const domStruct &currentDomStruct = strings[i].doms[j];
                
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 0] = currentDomStruct.posX;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 1] = currentDomStruct.posY;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 2] = currentDomStruct.posZ;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 3] = NAN;
                
                //std::cout << "string=" << i << " dom=" << j << ": pos=(" << currentDomStruct.posX << "," << currentDomStruct.posY << "," << currentDomStruct.posZ << ")" << std::endl;
                
            }
        }

        if (templateIndexIntoFlatList.size() < strings.size())
        {
            // templating works, there are identical strings
            
            /// new method: prepare output buffer
            std::ostringstream output(std::ostringstream::out);
            // write the output buffer
            output << "// this is auto-generated code created by generate_get_dom_position_code()" << std::endl;
            output << std::endl;
            output.setf(std::ios::scientific,std::ios::floatfield);
            output.precision(std::numeric_limits<float>::digits10+4); // maximum precision for a float

            //output << "#define GEO_DOM_POS_NUM_TEMPLATES " << templateIndexIntoFlatList.size() << std::endl;
            //output << "__constant unsigned short geoDomPosTemplateIndexIntoFlatList[GEO_DOM_POS_NUM_TEMPLATES] = {" << std::endl;
            //for (std::size_t i=0;i<templateIndexIntoFlatList.size();++i){     
            //    output << "  " << templateIndexIntoFlatList[i] << "," << std::endl;
            //}
            //output << "};" << std::endl;
            //output << "__constant unsigned short geoDomPosTemplateNumDoms[GEO_DOM_POS_NUM_TEMPLATES] = {" << std::endl;
            //for (std::size_t i=0;i<templateIndexIntoFlatList.size();++i){     
            //    output << "  " << templatePositionsZ[i].size() << "," << std::endl;
            //}
            //output << "};" << std::endl;
            output << "#define GEO_DOM_POS_MAX_ABS_X " << geoDomPosMaxAbsX << "f" << std::endl;
            output << "#define GEO_DOM_POS_MAX_ABS_Y " << geoDomPosMaxAbsY << "f" << std::endl;
            output << "#define GEO_DOM_POS_MAX_ABS_Z " << geoDomPosMaxAbsZ << "f" << std::endl;
            output << std::endl;
            
            output << "#define GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES " << templatePositionsX_flat.size() << std::endl;
            output << "__constant short geoDomPosTemplatePositionsX_flat[GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES] = {" << std::endl;
            for (std::size_t i=0;i<templatePositionsX_flat.size();++i){     
                const short value = static_cast<short>((templatePositionsX_flat[i]/geoDomPosMaxAbsX)*32767.);
                output << "  " << value << "," << std::endl;
            }
            output << "};" << std::endl;
            output << "__constant short geoDomPosTemplatePositionsY_flat[GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES] = {" << std::endl;
            for (std::size_t i=0;i<templatePositionsY_flat.size();++i){     
                const short value = static_cast<short>((templatePositionsY_flat[i]/geoDomPosMaxAbsY)*32767.);
                output << "  " << value << "," << std::endl;
            }
            output << "};" << std::endl;

            output << "__constant short geoDomPosTemplatePositionsZ_flat[GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES] = {" << std::endl;
            for (std::size_t i=0;i<templatePositionsZ_flat.size();++i){     
                const short value = static_cast<short>((templatePositionsZ_flat[i]/geoDomPosMaxAbsZ)*32767.);
                output << "  " << value << "," << std::endl;
            }
            output << "};" << std::endl;
            
            output << "#define GEO_DOM_POS_NUM_STRINGS " << strings.size() << std::endl;
            output << "__constant unsigned int geoDomPosStringStartIndexInTemplateDomList[GEO_DOM_POS_NUM_STRINGS] = {" << std::endl;
            for (std::size_t i=0;i<stringInTemplate.size();++i){     
                output << "  " << templateIndexIntoFlatList[stringInTemplate[i]] << "," << std::endl;
            }
            output << "};" << std::endl;

            output << "__constant short geoDomPosStringMeanPosX[GEO_DOM_POS_NUM_STRINGS] = {" << std::endl;
            for (std::size_t i=0;i<stringMeanPosX.size();++i){     
                const short value = static_cast<short>((stringMeanPosX[i]/geoDomPosMaxAbsX)*32767.);
                output << "  " << value << "," << std::endl;
            }
            output << "};" << std::endl;

            output << "__constant short geoDomPosStringMeanPosY[GEO_DOM_POS_NUM_STRINGS] = {" << std::endl;
            for (std::size_t i=0;i<stringMeanPosY.size();++i){     
                const short value = static_cast<short>((stringMeanPosY[i]/geoDomPosMaxAbsY)*32767.);
                output << "  " << value << "," << std::endl;
            }
            output << "};" << std::endl;

            
            output << "inline void geometryGetDomPosition(unsigned short stringNum, unsigned char domNum, float *domPosX, float *domPosY, float *domPosZ)" << std::endl;
            output << "{" << std::endl;
            
            output << "    const float stringMeanPosX = convert_float(geoDomPosStringMeanPosX[stringNum])*(GEO_DOM_POS_MAX_ABS_X/32767.f);" << std::endl;
            output << "    const float stringMeanPosY = convert_float(geoDomPosStringMeanPosY[stringNum])*(GEO_DOM_POS_MAX_ABS_Y/32767.f);" << std::endl;
            
            output << "    const unsigned int index = geoDomPosStringStartIndexInTemplateDomList[stringNum]+domNum;" << std::endl;
            output << "    *domPosX = convert_float(geoDomPosTemplatePositionsX_flat[index])*(GEO_DOM_POS_MAX_ABS_X/32767.f) + stringMeanPosX;" << std::endl;
            output << "    *domPosY = convert_float(geoDomPosTemplatePositionsY_flat[index])*(GEO_DOM_POS_MAX_ABS_Y/32767.f) + stringMeanPosY;" << std::endl;
            output << "    *domPosZ = convert_float(geoDomPosTemplatePositionsZ_flat[index])*(GEO_DOM_POS_MAX_ABS_Z/32767.f);" << std::endl;
            output << "}" << std::endl;
            output << std::endl;
            
            
            
            output << "// end of auto-generated code created by generate_get_dom_position_code()" << std::endl;
            output << std::endl;
            return output.str();


        }
        else
        {
            // templating does NOT work, generate old-style code

            log_warn("Got as many templates as strings, no memory savings from templating. Using full tables per string.");
            
            std::ostringstream output(std::ostringstream::out);
            // write the output buffer
            output << "// this is auto-generated code created by generate_get_dom_position_code()" << std::endl;
            output << std::endl;
            output.setf(std::ios::scientific,std::ios::floatfield);
            output.precision(std::numeric_limits<float>::digits10+4); // maximum precision for a float

            output << "#define GEO_DOM_POS_MAX_NUM_DOMS_PER_STRINGS " << maxNumDoms << std::endl;
            output << "#define GEO_DOM_POS_NUM_STRINGS " << strings.size() << std::endl;
            
            // we only have a limited amount of constant memory. this needs lots of memory,
            // so store it as shorts with a known multiplier.
            output << "#define GEO_DOM_POS_MAX_ABS_X " << geoDomPosMaxAbsX << "f" << std::endl;
            output << "__constant short geoDomPosX[GEO_DOM_POS_NUM_STRINGS*GEO_DOM_POS_MAX_NUM_DOMS_PER_STRINGS] = {" << std::endl;
            for (std::size_t i=0;i<strings.size();++i){     
                for (std::size_t j=0;j<maxNumDoms;++j){    
                    short value = static_cast<short>((domPosBuffer[i*(maxNumDoms*4)+j*4 + 0]/geoDomPosMaxAbsX)*32767.);
                    
                    output << "  " << value << ", // string=" << i << ", dom=" << j << std::endl;
                }
            }
            output << "};" << std::endl;
            
            output << "#define GEO_DOM_POS_MAX_ABS_Y " << geoDomPosMaxAbsY << "f" << std::endl;
            output << "__constant short geoDomPosY[GEO_DOM_POS_NUM_STRINGS*GEO_DOM_POS_MAX_NUM_DOMS_PER_STRINGS] = {" << std::endl;
            for (std::size_t i=0;i<strings.size();++i){     
                for (std::size_t j=0;j<maxNumDoms;++j){    
                    short value = static_cast<short>((domPosBuffer[i*(maxNumDoms*4)+j*4 + 1]/geoDomPosMaxAbsY)*32767.);
                    
                    output << "  " << value << ", // string=" << i << ", dom=" << j << std::endl;
                }
            }
            output << "};" << std::endl;
            
            output << "#define GEO_DOM_POS_MAX_ABS_Z " << geoDomPosMaxAbsZ << "f" << std::endl;
            output << "__constant short geoDomPosZ[GEO_DOM_POS_NUM_STRINGS*GEO_DOM_POS_MAX_NUM_DOMS_PER_STRINGS] = {" << std::endl;
            for (std::size_t i=0;i<strings.size();++i){     
                for (std::size_t j=0;j<maxNumDoms;++j){    
                    short value = static_cast<short>((domPosBuffer[i*(maxNumDoms*4)+j*4 + 2]/geoDomPosMaxAbsZ)*32767.);
                    
                    output << "  " << value << ", // string=" << i << ", dom=" << j << std::endl;
                }
            }
            output << "};" << std::endl;
            output << std::endl;

            output << "inline void geometryGetDomPosition(unsigned short stringNum, unsigned char domNum, float *domPosX, float *domPosY, float *domPosZ)" << std::endl;
            output << "{" << std::endl;
            output << "    const unsigned int domIndex = stringNum*GEO_DOM_POS_MAX_NUM_DOMS_PER_STRINGS+domNum;" << std::endl;
            output << "    " << std::endl;
            output << "    *domPosX = convert_float(geoDomPosX[domIndex])*(GEO_DOM_POS_MAX_ABS_X/32767.f);" << std::endl;
            output << "    *domPosY = convert_float(geoDomPosY[domIndex])*(GEO_DOM_POS_MAX_ABS_Y/32767.f);" << std::endl;
            output << "    *domPosZ = convert_float(geoDomPosZ[domIndex])*(GEO_DOM_POS_MAX_ABS_Z/32767.f);" << std::endl;
            output << "}" << std::endl;
            output << std::endl;
            
            
            
            
            output << "// end of auto-generated code created by generate_get_dom_position_code()" << std::endl;
            output << std::endl;
            return output.str();
        }
        
    }
    
    
    bool write_geometry_code_and_fill_buffer(std::string &code, 
                                             const std::vector<int> &stringIDs,
                                             const std::vector<unsigned int> &domIDs,
                                             const std::vector<double> &posX,
                                             const std::vector<double> &posY,
                                             const std::vector<double> &posZ,
                                             const double omRadius,
                                             std::vector<cl_uchar> &geoLayerToOMNumIndexPerStringSetBuffer,
                                             std::vector<int> &stringIndexToStringIDBuffer
                                             )
    {
        typedef std::vector<int>::size_type sizeType;
        
        sizeType numEntries=stringIDs.size();
        if (numEntries==0) {std::cerr << "Empty geometry provided." << std::endl; return false;}
        if ((domIDs.size() != numEntries) ||
            (posX.size() != numEntries) ||
            (posY.size() != numEntries) ||
            (posZ.size() != numEntries))
            return false;
        if (omRadius < 0.) {std::cerr << "Zero or negative OM radius." << std::endl; return false;}
        
        std::set<int> stringIDSet;
        BOOST_FOREACH(int stringID, stringIDs) {stringIDSet.insert(stringID);}
        
        #define MAX_SUPPORTED_NUM_STRINGS 0xFFFF-1
        if (stringIDSet.size() >= MAX_SUPPORTED_NUM_STRINGS) {
            std::cerr << "More than " << MAX_SUPPORTED_NUM_STRINGS << " are not supported." << std::endl;
            return false;
        }
        
        std::vector<stringStruct> strings(stringIDSet.size());
        unsigned int stringIndex=0;
        double stringMaxR=NAN;
        BOOST_FOREACH(int stringID, stringIDSet)
        {
            stringStruct &currentStringStruct = strings[stringIndex];
            
            currentStringStruct.stringID = stringID;
            currentStringStruct.maxZ=NAN;
            currentStringStruct.minZ=NAN;
            currentStringStruct.meanX=0.;
            currentStringStruct.meanY=0.;
            currentStringStruct.maxR=NAN;
            currentStringStruct.doms.clear();
            
            // loop over all doms. only use them if they are on the current string
            unsigned long numDoms=0;
            for (unsigned long i=0;i<numEntries;++i)
            {
                if (stringIDs[i]!=stringID) continue;
                // index i is on the current string!
                
                currentStringStruct.meanX += posX[i];
                currentStringStruct.meanY += posY[i];
                if ((posZ[i] > currentStringStruct.maxZ) || isnan(currentStringStruct.maxZ))
                    currentStringStruct.maxZ = posZ[i];
                if ((posZ[i] < currentStringStruct.minZ) || isnan(currentStringStruct.minZ))
                    currentStringStruct.minZ = posZ[i];
                
                // insert this dom
                currentStringStruct.doms.push_back(domStruct());
                domStruct &currentDomStruct = currentStringStruct.doms.back();
                
                currentDomStruct.domID = domIDs[i];
                currentDomStruct.posX = posX[i];
                currentDomStruct.posY = posY[i];
                currentDomStruct.posZ = posZ[i];
                
                ++numDoms;
            }
            currentStringStruct.meanX /= static_cast<double>(numDoms);
            currentStringStruct.meanY /= static_cast<double>(numDoms);
            
            log_trace("String %u has minZ=%f, maxZ=%f, numDoms=%lu",
                      stringIndex, currentStringStruct.minZ, currentStringStruct.maxZ,
                      numDoms);

            // calculate the string radius (will be the OM radius for a straight string)
            for (unsigned long i=0;i<numEntries;++i)
            {
                if (stringIDs[i]!=stringID) continue;
                // index i is on the current string!
                
                const double dX = currentStringStruct.meanX - posX[i];
                const double dY = currentStringStruct.meanY - posY[i];
                const double thisR = std::sqrt(dX*dX + dY*dY)+omRadius;
                
                if ((thisR > currentStringStruct.maxR) || isnan(currentStringStruct.maxR))
                    currentStringStruct.maxR = thisR;
                
                if ((thisR > stringMaxR) || isnan(stringMaxR))
                    stringMaxR = thisR;
            }
            
            log_trace("String %u has radius %f",
                      stringIndex, currentStringStruct.maxR);
            
            ++stringIndex;
        }
        
        log_trace("Number of strings is %zu", strings.size());
        
        // Try to split the detector into xy "cells" with 0 or 1 strings per cell.
        // We do not need to optimize this, so we do a brute froce approach:
        // start with only one cell and subdivide it until the requirement 
        // max(Nstringpercell)==1 is fulfilled.
        unsigned int cellGridNumX=1;
        unsigned int cellGridNumY=1;
        std::vector<unsigned short> cellToStringIndex;
        double cellStartX, cellStartY, cellWidthX, cellWidthY;
        for(;;)
        {
            bool divisionIsPossible = divideIntoCells(strings,
                                                      cellStartX,
                                                      cellStartY,
                                                      cellWidthX,
                                                      cellWidthY,
                                                      cellGridNumX,
                                                      cellGridNumY,
                                                      cellToStringIndex);
            
            if (divisionIsPossible) break;
            ++cellGridNumX;
            ++cellGridNumY;
            
            if (cellGridNumX >= 1000) {
                std::cerr << "Could not generate a cell division for your detector." << std::endl;
                exit(-3);
            }
        }
        log_debug("Geometry cell division: %ux%u", cellGridNumX, cellGridNumY);
        log_debug("from x=%fm, width=%fm", cellStartX, cellWidthX);
        log_debug("from y=%fm, width=%fm", cellStartY, cellWidthY);
        
        // try to split the detector into z "layers" with either a single dom number in it or
        // no dom number at all. We restrict ourselves to a detector where dom z-positions are
        // correlated to their numbers.
        
        unsigned int numStringSets=0;
        std::vector<unsigned int> geoLayerNum;
        std::vector<double> layerStartZ, layerHeight;
        
        std::vector<std::vector<unsigned char> > layerToOMNumIndexPerStringSet;
        std::vector<unsigned char> stringInStringSet(strings.size()); 
        
        double minZHint, maxZHint;
        findOverallStringMinMaxZ(strings, omRadius, minZHint, maxZHint);
        
        log_trace("overall minZ=%fm, maxZ=%fm", minZHint, maxZHint);
        
        unsigned int maxLayerNum=0;
        for (unsigned int stringNum=0;stringNum<strings.size();++stringNum)
        {
            //std::cout << "checking string " << stringNum << std::endl;
            // first check if the current string matches one of the previous layer division
            
            bool matchFound=false; unsigned int existingStringSetNum;
            for (unsigned int stringSetNum=0;stringSetNum<numStringSets;++stringSetNum)
            {
                //std::cout << "  cheking if it matches layering " << stringSetNum << std::endl;
                
                bool ret = doesMatchLayering(strings[stringNum],
                                             layerStartZ[stringSetNum],
                                             layerHeight[stringSetNum],
                                             geoLayerNum[stringSetNum],
                                             omRadius,
                                             layerToOMNumIndexPerStringSet[stringSetNum]);
                if (ret) {existingStringSetNum=stringSetNum;matchFound=true; break;}
            }
            if (matchFound)
            {
                //std::cout << "  YES!" << std::endl;
                
                // not much work to be done here
                stringInStringSet[stringNum] = existingStringSetNum;
            }
            else
            {
                stringInStringSet[stringNum] = numStringSets;
                //std::cout << "  NO -> creating new layering " << numStringSets << std::endl;
                
                // need to create a new layering for this string
                ++numStringSets;
                if (numStringSets >= 0xFF) {
                    std::cerr << "Not more than 255 different string layer divisions (\"string sets\") are supported!" << std::endl;
                    exit(-5);
                }
                
                layerStartZ.push_back(NAN);
                layerHeight.push_back(NAN);
                geoLayerNum.push_back(1);
                layerToOMNumIndexPerStringSet.push_back(std::vector<unsigned char>());
                
                for(;;)
                {
                    bool divisionIsPossible = divideIntoLayers(strings[stringNum],
                                                               layerStartZ.back(),
                                                               layerHeight.back(),
                                                               geoLayerNum.back(),
                                                               omRadius,
                                                               minZHint, maxZHint,
                                                               layerToOMNumIndexPerStringSet.back());
                    if (divisionIsPossible) break;
                    ++geoLayerNum.back();
                    
                    if (geoLayerNum.back() >= 1000) {
                        std::cerr << "There does not seem to be a possible layer division for your detector." << std::endl;
                        exit(-3);
                    }
                }
                
                if (geoLayerNum.back()>maxLayerNum) maxLayerNum=geoLayerNum.back();
                
                //std::cout << "   new layering created! Contains " << geoLayerNum.back() << " layers." << std::endl;
                //for (unsigned int l=0;l<geoLayerNum.back();++l)
                //{
				//if (layerToOMNumIndexPerStringSet.back()[l] == 0xFF) continue;
				//std::cout << "    layer " << l << " -> OM " << (int)(layerToOMNumIndexPerStringSet.back()[l]) << std::endl;
				
                //}
                
            } // end if (matchfound)
            
        } // for (stringNum)
        
        std::vector<unsigned char> geoLayerToOMNumIndex(maxLayerNum*numStringSets, 0xFF);
        for (unsigned int j=0;j<numStringSets;++j)
        {
            for (unsigned int i=0;i<geoLayerNum[j];++i)
            {
                geoLayerToOMNumIndex[j*maxLayerNum+i] = layerToOMNumIndexPerStringSet[j][i];
            }
        }
        
        log_info("There are %u string sets:", numStringSets);
        for (unsigned int stringSetNum=0;stringSetNum<numStringSets;++stringSetNum)
        {
            log_info(" * Set %u:", stringSetNum);
            log_info("   Geometry layer division: %u layers", geoLayerNum[stringSetNum]);
            log_info("   from z=%fm, height=%fm",
                     layerStartZ[stringSetNum],
                     layerHeight[stringSetNum]);
        }
        
        
        unsigned int geoLayerToOMNumIndexPerStringSetBuffer_size = ((numStringSets*maxLayerNum)/64)+1;
        geoLayerToOMNumIndexPerStringSetBuffer_size *= 64;
        log_debug("BSize: %u -> %u", numStringSets*maxLayerNum, geoLayerToOMNumIndexPerStringSetBuffer_size);
        
        geoLayerToOMNumIndexPerStringSetBuffer.assign(geoLayerToOMNumIndexPerStringSetBuffer_size,0xFF);
        for (unsigned int i=0;i<numStringSets*maxLayerNum;++i)
        {
            geoLayerToOMNumIndexPerStringSetBuffer[i] = geoLayerToOMNumIndex[i];
        }
        
        // initialize the stringIndex to stringID buffer
        stringIndexToStringIDBuffer.resize(strings.size());
        for (std::size_t i=0;i<strings.size();++i)
        {
            stringIndexToStringIDBuffer[i] = strings[i].stringID;
        }
        
        // string information goes to the constant memory
        
        // prepare the output buffer
        std::ostringstream output(std::ostringstream::out);
        
        // write the output buffer
        output << "// this is auto-generated code created by write_geometry_code_and_fill_buffer()" << std::endl;
        output << std::endl;
        
        
        output.setf(std::ios::scientific,std::ios::floatfield);
        output.precision(std::numeric_limits<float>::digits10+4); // maximum precision for a float
        

        // the dom position lookup code (i.e. (stringNum,domNum)->(posX, posY, posZ) )
        output << generate_get_dom_position_code(strings);
        
        
        // all the other data
        output << "#define NUM_STRINGS " << strings.size() << std::endl;
        output << "#define OM_RADIUS " << omRadius << "f" << std::endl;
        
        output << "#define GEO_CELL_NUM_X " << cellGridNumX << std::endl;
        output << "#define GEO_CELL_NUM_Y " << cellGridNumY << std::endl;
        output << "#define GEO_CELL_WIDTH_X " << cellWidthX << "f" << std::endl;
        output << "#define GEO_CELL_WIDTH_Y " << cellWidthY << "f" << std::endl;
        output << "#define GEO_CELL_START_X " << cellStartX << "f" << std::endl;
        output << "#define GEO_CELL_START_Y " << cellStartY << "f" << std::endl;
        
        output << "#define GEO_LAYER_STRINGSET_NUM " << numStringSets << std::endl;
        output << "#define GEO_LAYER_STRINGSET_MAX_NUM_LAYERS " << maxLayerNum << std::endl;
        
        output << std::endl;
        
        //output << "__constant const short geoStringIDs[NUM_STRINGS] = {" << std::endl;
        //for (sizeType j=0;j<strings.size();++j){     
        //	output << "  " << strings[j].stringID << ", " << std::endl;
        //}
        //output << "};" << std::endl;
        //output << std::endl;
        
        output << "__constant unsigned char geoStringNumDoms[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].doms.size() << ", " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringPosX[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].meanX << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringPosY[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].meanY << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "#define GEO_STRING_MAX_RADIUS " << stringMaxR << "f" << std::endl;
        output << "__constant float geoStringRadius[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].maxR << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringMinZ[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].minZ << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringMaxZ[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].maxZ << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;

        
        output << "__constant unsigned short geoCellIndex[GEO_CELL_NUM_X*GEO_CELL_NUM_Y] = {" << std::endl;
        for (sizeType j=0;j<cellGridNumY;++j){
            for (sizeType i=0;i<cellGridNumX;++i){     
                unsigned short value = cellToStringIndex[j*cellGridNumX+i];
                if (value == 0xFFFF) {
                    output << "  " << "0xFFFF" << ", " << std::endl;
                } else {
                    output << "  " << value << ", " << std::endl;
                }
            }
        }
        output << "};" << std::endl;
        
        
        output << "__constant unsigned char geoStringInStringSet[NUM_STRINGS] = {" << std::endl;
        for (unsigned int i=0;i<strings.size();++i)
        {
            output << "  " << (int)stringInStringSet[i] << ", " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant unsigned short geoLayerNum[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << geoLayerNum[i] << ", " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant float geoLayerStartZ[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << layerStartZ[i] << "f, " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant float geoLayerHeight[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << layerHeight[i] << "f, " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "#define GEO_geoLayerToOMNumIndexPerStringSet_BUFFER_SIZE " << geoLayerToOMNumIndexPerStringSetBuffer_size << std::endl;
        output << "__constant unsigned char geoLayerToOMNumIndexPerStringSet[GEO_LAYER_STRINGSET_NUM*GEO_LAYER_STRINGSET_MAX_NUM_LAYERS] = {" << std::endl;
        for (unsigned int j=0;j<numStringSets;++j)
        {
            for (unsigned int i=0;i<maxLayerNum;++i)
            {
                unsigned int value = geoLayerToOMNumIndex[j*maxLayerNum+i];
                if (value == 0xFF) {
                    output << "  " << "0xFF" << ", ";
                } else {
                    output << "  " << value << ", ";
                }
            }
            output << std::endl;
        }
        output << "};" << std::endl;
        
        // return the code we just wrote to the caller
        code = output.str();
        
        return true;
    }
    
    

};
